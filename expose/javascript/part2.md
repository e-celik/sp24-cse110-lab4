1. 3: The program will print the value of i, which is currently 3, because it is in scope, and was incremented to prices.length by the for loop.
2. 150: discountedPrice is in scope, and the value of item 3 half off, which is the last item to be processed.
3. 150, which is the value of finalPrice when line 14 is run.
4. The function returns an array (list?) of the 3 discounted prices
5. ERROR: i is not in scope, because it was declared using let, and is only valid in that block.
6. ERROR: i is not in scope, because it was declared using let, and is only valid in that block.
7. 150: finalPrice is in scope, and was last assigned to 150.
8. The function returns an array of the 3 discounted prices. This is because discounted is still in scope for return.
9. ERROR: i is not in scope, it was declared with let in a different block.
10. 3: length is only set once, and is in scope.
11. It will return the array [50,100,150], as expected. discounted is declared const, but values can be pushed to it, as const only means const reference in this context.
12. a) student.name
    b) student.major['Grad Year']
    c) student.greeting()
    d) student['Favorite Teacher'].name
    e) student.courseLoad[0]

13. a) '32'
    b) 1
    c) 3
    d) '3null'
    e) 4
    f) 0
    g) '3undefined'
    h) NaN

14. a) true
    b) false
    c) true
    d) false
    e) false
    f) true

15. == performs type conversions, and is therefore musch looser, while === is a more traditional operator that takes type into accoubtm and is therefore stricter.
16. Done!
17. [1,2,3] and doSomething are passed into modify array. newArr is declared, and a for loop inserts callback(element in array) into newArr. Now, newArr is [soSomething[1], doSomethimg[2], doSomething[3]], which evaluates to [2, 4, 6], which is what is returned.
18. Done!
19. 1 4 3 2
    
    